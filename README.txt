The functions in these modules take a set of files generated by post-processing Database entries and search for a specific cyclic pattern in the strongly connected components of the wall graph. The current form of the input files from the Database will change, and so the module fileparsers.py will soon be obsolete. The content of the Database files is eventually transformed (using preprocess.py) into the following:

(1) A list of tuples containing the outedges of each graph node that belongs to a nontrivial strongly connected component. A renumbering is performed on the wall graphs so that the index of the index refers to the wall number. A list of the original wall numbers is saved, connecting the new indices with the old numbers.

(2) A list of tuples containing a description of the values of the variables at each wall. For example, (0.5,1,2.5) means that the first variable is below its first threshold, the second variable is at its first threshold, and the third variable is above its second threshold.

(3) A list of the variables affected at each wall, using the threshold order for the chosen model. For example, the model may contain the line X2 : X3 : X3, so that X3 is affected at (0.5,1,2.5) for the order (X1,X2,X3). 

(4) A list of the names of the variables associated to their indices in each element of wall domains. For example, ['X1', 'X2', 'X3'] in the above example.

There is an additional file (patterns.txt) supplied by the user making the query that contains newline separated patterns of the form:

	X1 max, X2 min, X1 min, X3 max, X2 max, X3 min

All patterns are assumed to be cyclic, and the variable names must match those in the Database model. These patterns can be translated into words from the alphabet 'u', 'd', 'M', and 'm', standing for up, down, maximum, and minimum respectively. For example, take X1 min in the above pattern. It is given that X1 is at a minimum, so the first letter of the word must be 'm'. Since X2 was previously at a minimum, it must now be increasing, so the next letter is 'u'. Finally, X3 was previously at a minimum, assuming a cycle, giving the word 'muu'. The correct letter order within each word is determined by the list of variable names from (4).

In order to search the walls for the indicated pattern, it is necessary to assign a set of these words to each wall, called wall labels. The wall labels are path dependent. A list of all possible wall labels for each wall is constructed in walllabels.py, using the information in (1)-(3). 

This is the last piece of information needed to call matchCyclicPattern() in patternmatch.py. The heart of the algorithm is the function recursePattern() in the same module. Basically, you identify the possible walls where the pattern starts, and then step to matching nodes from there. There are two sanity checks inside the recursive call. One double-checks that a repeating patterns do not exist in the current match. This is to avoid infinite loops, but means that user-defined patterns containing a repeating sub-loop will not be found. The other check makes sure that the sequence of wall labels is consistent with the path through the graph. Since each wall can have multiple labels, there might be a false positive match unless the specific path is checked. There is perhaps a potential speed-up if I move this second check outside of the recursion. It depends how large the graph is and how many potential paths are weeded out by checking during the recursion. There is (some) documentation/code commenting within the module. 

Please contact me at breecummins@gmail.com for questions.