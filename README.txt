The functions in these modules take a json file generated by post-processing Database entries and search for a pattern in the labeled wall graph of a specified Morse set. The content of the json file is eventually transformed (using preprocess.py) into the following:

(1) A list of tuples containing the outedges of each wall graph node.

(2) A list of tuples containing a description of the values of the variables at each wall. For example, (0.5,1,2.5) means that the first variable is below its first threshold, the second variable is at its first threshold, and the third variable is above its second threshold.

(3) A list of the names of the variables associated to their indices in each element of wall domains. For example, ['X1', 'X2', 'X3'] or ['X2', 'X1', 'X3'] are possible orderings of a 3D model.

(4) A list of the variables affected at each wall, using the threshold order for the chosen model. For example, if variable X2 affects X3 at threshold 1, then X3 is affected at wall (X1,X2,X3) = (0.5,1,2.5) for the variable name list ['X1', 'X2', 'X3']. 

There is an additional file (patterns.txt) supplied by the user making the query that contains newline separated patterns of the form:

	X1 max, X2 min, X1 min, X3 max, X2 max, X3 min

The variable names must match those in the Database model. The patterns must be declared cyclic or acyclic when calling matchPattern in patternmatch.py. The default is cyclic. The patterns are translated into words from the alphabet 'u', 'd', 'M', and 'm', standing for up, down, maximum, and minimum respectively. For example, take X1 min in the above pattern. It is given that X1 is at a minimum, so the first letter of the word must be 'm'. Since X2 was previously at a minimum, it must now be increasing, so the next letter is 'u'. Finally, X3 will next be at a maximum, so it must be increasing, in sum giving the word 'muu'. The correct letter order within each word is determined by the list of variable names as in (3).

In order to search the walls for the indicated pattern, it is necessary to assign a set of these words to each wall, called wall labels. The wall labels are path dependent. Because of this, every allowable wall triple (last wall, current wall, next wall) is associated to a set of allowable wall labels using the information in (1)-(4) in the module walllabels.py. The list of wall labels is saved in two different forms that index by last wall and current wall respectively, because this saves time in the recursive algorithm. 

Now we can call matchPattern() in patternmatch.py. The heart of the algorithm is the function recursePattern() in the same module. Basically, you identify the possible walls where the pattern starts, and then step to matching nodes (or allowable intermediate nodes) from there. There is (some) documentation/code commenting within the module. 

matchPattern() can be instructed to find only the first match with optional argument findallmatches=0. The default is locate all matches.

There is a helper function callPatternMatch() in patternmatch.py that does the preprocessing and saves positive results to a file. 

Please contact me at breecummins@gmail.com for questions.